# 3. ゲームの仕組み

ここからは、このゲームが実際にどのように動いているのか、コードの核心部分を覗いていきましょう。
このアプリケーションの動作は、大きく分けて2つの要素の連携によって成り立っています。

1.  **ゲームの状態とルール (ロジック)**: `gameLogic.ts` と `types.ts`
2.  **画面の表示とユーザー操作 (UI)**: `App.tsx` と `components` フォルダ

「ユーザーがカードをクリックしたとき」を例に、この2つがどのように連携するかを見ていきましょう。

## 1. すべての基本、「ゲームの状態(State)」

`App.tsx` の中にある `gameState` という変数が、現在のゲームの状況すべてを保持しています。
この `gameState` の中身は `src/types.ts` で `GameState` 型として定義されています。

```typescript
// src/types.ts
export type GameState = {
  board: CardType[];      // 25枚のカードの情報
  currentTeam: Team;      // 現在どちらのチームのターンか
  redRemaining: number;   // 赤チームの残り枚数
  blueRemaining: number;  // 青チームの残り枚数
  winner: Team | null;    // 勝者チーム (決まってなければ null)
  gameOver: boolean;      // ゲームが終了したか
  viewMode: ViewMode;     // 'agent' (通常) or 'spymaster' (答え表示)
};
```

**Reactの基本思想は、「この `gameState` というデータに基づいて画面を描画する」というものです。**
例えば、`gameOver` が `true` になれば、Reactは自動的に「ゲーム終了！」というメッセージを画面に表示します。開発者は「もしゲームオーバーなら、このメッセージを表示しろ」とあらかじめ宣言しておくだけです。

## 2. ユーザーのアクションと状態の更新

ユーザーがカードをクリックすると、何が起こるのでしょうか。

**(1) `Card.tsx` → `Board.tsx` → `App.tsx`**

*   ユーザーがブラウザ上でカードをクリックします。
*   クリックイベントは、まずカード1枚のコンポーネント (`Card.tsx`) に伝わります。
*   `Card.tsx` は、自分自身が何番目のカードなのかという情報 (`index`) を持って、親である `Board.tsx` に通知します。
*   `Board.tsx` は、さらにその親である `App.tsx` に通知します。
*   最終的に `App.tsx` の `handleCardClick` という関数が、クリックされたカードの `index` を受け取って実行されます。

**(2) `App.tsx` が `gameLogic.ts` を呼び出す**

`handleCardClick` の中身は以下のようになっています。

```typescript
// src/App.tsx
const handleCardClick = (index: number) => {
  // `gameLogic.ts` の `selectCard` 関数を呼び出す
  // 引数として「現在のゲーム状態」と「クリックされたカードの番号」を渡す
  const newState = selectCard(gameState, index);

  // `selectCard` が返した「新しいゲーム状態」で、現在の状態を更新する
  setGameState(newState);
};
```

ポイントは、`App.tsx` 自身はカードがクリックされたときの複雑なルール（アサシンを踏んだら負け、など）を知らないことです。
**UI担当の `App.tsx` は、ロジック担当の `gameLogic.ts` に判断を丸投げします。**

**(3) `gameLogic.ts` が新しい状態を計算する**

`selectCard` 関数は、現在の状態とクリックされたカードの位置を受け取り、ルールに従って「次の状態」を計算して作り出します。

```typescript
// src/gameLogic.ts
export function selectCard(currentState: GameState, cardIndex: number): GameState {
  // ... (すでにクリックされているカードなら何もしない、などのチェック)

  const newState = JSON.parse(JSON.stringify(currentState)); // 現在の状態をコピーして新しい状態を作る
  const card = newState.board[cardIndex];
  card.revealed = true; // カードを表にする

  // カードの役割(role)に応じて、状態を更新する
  switch (card.role) {
    case 'assassin':
      // アサシンカードの場合
      newState.gameOver = true;
      newState.winner = opponentTeam; // 相手チームの勝利
      break;

    case currentTeam:
      // 自分のチームのカードの場合
      // 残り枚数を減らし、もし0になったら勝利
      break;

    // ... (相手チームのカードの場合、中立カードの場合)
  }

  // 計算して作り出した「新しい状態」を返す
  return newState;
}
```

**(4) `App.tsx` が状態を更新し、画面が再描画される**

*   `gameLogic.ts` から返された `newState` を使って、`App.tsx` は `setGameState(newState)` を呼び出します。
*   `gameState` が新しいものに置き換わったことをReactが検知します。
*   Reactは、**新しい `gameState` と古い `gameState` の差分を自動で計算**し、画面の表示に必要な部分だけを効率的に更新します。
    *   クリックされたカードの色が変わる。
    *   チームの残り枚数の表示が減る。
    *   もしゲームオーバーなら、「ゲーム終了！」メッセージが表示される。

## まとめ

このように、このアプリケーションは以下の流れを繰り返すことで動作しています。

1.  現在の `gameState` に基づいて画面を表示する。
2.  ユーザーが何か操作（クリックなど）を行う。
3.  UIコンポーネント (`App.tsx`) が、ロジック担当 (`gameLogic.ts`) に処理を依頼する。
4.  ロジック担当が、現在の状態とユーザーの操作に基づいて、**全く新しい `gameState`** を作る。
5.  UIコンポーネントが、新しい `gameState` で状態を更新する。
6.  Reactが状態の変更を検知し、画面を自動で再描画する。→ 1. に戻る。

この「**状態(State) -> 表示(View) -> アクション(Action) -> 状態の更新**」という一方通行のデータの流れが、Reactアプリケーションの基本であり、コードを整理し、予測可能にするための重要な考え方です。

次は、これを踏まえて「[開発の進め方](./04_開発の進め方.md)」について考えてみましょう。
